h1. Service layer

In term of design, the service project is very similar to the persistence because we will create an interface and its implementation. Why repeating the interface. The answer is evident; it is for decoupling the service from the DAO implentation to allow you to switch easily from one ORM to another, ...

STEP 1 : Edit the following file {{src/main/java/org/fusesource/devoxx/reportincident/service/IncidentService.java}} in the module {{service}}

{snippet:url=src/main/snippets/IncidentService.java}
{snippet}

STEP 2 : Edit its implementation in the sub-directory {{impl/IncidentServiceImpl.java}}

{snippet:url=src/main/snippets/IncidentService.java}
{snippet}

As you see, we will use {{IncidentDAO}} class within the {{IncidentServiceImpl}} class. The injection of this bean will be done by Spring. As Spring will be used as Transaction Manager, the service layer will be configured to define which class/methods are transactional and which scope "PROPAGATION_REQUIRED" will be used to check / retrieve the transaction from the transaction manager. We will not use @Transactional annotation but the could be easily transformed to use Spring Transactional Annotations

STEP 3 : Edit the file {{src/main/resources/META-INF/spring/spring-service-beans-dao.xml}}

{snippet:url=src/main/snippets/spring-service-beans-dao.xml}
{snippet}

STEP 4 : The last step requires that we expose our Service on the OSGI container to allow the Apache Camel route as well as the Apache Wicket web application to use it

{snippet:url=src/main/snippets/spring-service-beans-dao-osgi.xml}
{snippet}

After the creation of the Service layer, we have finished to put in place the DAO / Services layers, Transaction Management and register the Services for the CRUD. It is time now to design the web service, create the camel routes and install the Web project
