h1. Routing

The routing/mediation between "services" will be created using Camel Spring DSL language. We will describe its creation/genesis step by step
* Define ActiveMQ component
* Define Beans that Apache Camel will use to insert records in DB (IncidentSaver), extract info from the webservice (WebService.java) and prepare the response for the Web Service (Feedback.java)
* Configure CXF endpoint
* Camel routes and DataFormats

STEP 1 : Edit the file {{src/main/resources/META-INF/spring/camel-context.xml}} file in the {{routing}} module and add the following bean for the ActiveMQ component

{snippet:url=src/main/snippets/routing-activemq.xml}
{snippet}

Remarks :
We retrieve the JMS {{ConnectionFactory}} (similar to a {{DataSource}} in the JDBC realm) from the OSGI Service Registry. The component is transactional and can participate in a transaction if we configure a {{org.springframework.transaction.PlatformTransactionManager}}.  Once again, we are retrieving a suitable instance from the OSGi Service Registry.

STEP 2 : Add beans definitions.  Camel has excellent support for using Java beans in your routes (cfr. [http://camel.apache.org/bean-integration.html]) and our example routes will be using these 3 beans.

{snippet:url=src/main/snippets/routing-beans.xml}
{snippet}

Remark : The {{IncidentSaver}} class has a property {{incidentService}}.  Once again, we will retrieve and inject this bean proxy using Spring DM.

STEP 3 : Configure the CXF endpoint

{snippet:url=src/main/snippets/routing-cxf.xml}
{snippet}

Remark :
CXF uses Jetty (Web Application Server project managed by Eclipse community) to expose the Web Service. In this case, we will create a web server instance running on the port 8282.

The webservice uses the {{ReportIncidentEndpoint}} interface created in the project {{webservice}}. This is this service that will receive the SOAP envelope and extract the body. Afterwards, when the Apache Camel route is done creating the response, it will prepare the SOAP response message for the HTTP client.

STEP 4 : Define the transaction policy that Apache Camel will use

{snippet:url=src/main/snippets/routing-txmanager.xml}
{snippet}

Remark : we will reuse the JPA transaction manager created in the {{persistence-jpa}} module and exposed as an OSGi Service

STEP 5 : Create the Camel Context

{snippet:url=src/main/snippets/routing-context.xml}
{snippet}

STEP 6 : Add the data format definition that Apache Camel will use to transform CSV record into objects (or objects into CSV)

{snippet:url=src/main/snippets/routing-dataformat.xml}
{snippet}

STEP 7 : Create the route which will poll files from a directory, transform the content into a ReportIncident and place it into a queue

{snippet:url=src/main/snippets/routing-file-route.xml}
{snippet}

STEP 8 : Expose a webservice, send the response to the caller and place ReportIncident object into the queue

{snippet:url=src/main/snippets/routing-webservice-route.xml}
{snippet}

STEP 9 Create the camel transactional route which will insert records into the h2 DB

{snippet:url=src/main/snippets/routing-activemq-route.xml}
{snippet}

STEP 10 : Create the following classes in the directory {{src/main/java/org/fusesource/devoxx/reportingincident/internal}}

WebService

{snippet:url=src/main/snippets/routing-WebService.java}
{snippet}

IncidentSaver

{snippet:url=src/main/snippets/routing-IncidentSaver.java}
{snippet}

Feedback

{snippet:url=src/main/snippets/routing-Feedback.java}
{snippet}



